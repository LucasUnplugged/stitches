{"version":3,"sources":["../src/toCase.js","../src/getResolvedSelectors.js","../src/Array.js","../src/index.js"],"names":["toKebabCase","value","includes","replace","capital","toLowerCase","getResolvedSelectors","parentSelectors","nestedSelectors","reduce","resolvedSelectors","parentSelector","push","map","selector","test","isArray","Array","prototype","toString","Object","comma","stringify","replacer","used","WeakSet","parse","style","selectors","conditions","prevName","prevData","cssText","each","name","isAtRuleLike","charCodeAt","data","next","has","delete","usedName","nextSelectors","length","split","concat","i","add","String"],"mappings":"AACO,IAAMA,EAAqCC,GAEjDA,EAAMC,SAAS,KACZD,EAEDA,EAAME,QAAQ,UAAWC,GAAY,IAAMA,EAAQC,gBCLzCC,EAAuB,CAEnCC,EAEAC,IAEAD,EAAgBE,QACf,CAACC,EAAmBC,KACnBD,EAAkBE,QACdJ,EAAgBK,KACjBC,GACAA,EAASZ,SAAS,KAAOY,EAASX,QACjC,KACA,UAAUY,KAAKJ,IAAmB,OAAOI,KAAKD,GAC3C,OAAOH,KACRA,GACCA,EAAiB,IAAMG,KAKvBJ,IAER,KCxBWM,QAAEA,GAAYC,OCInBC,WAAWC,SAAEA,IAAeC,OAG9BC,EAAQ,sBAGDC,EAAY,CAExBrB,EAEAsB,KAGA,MAAMC,EAAO,IAAIC,QAEXC,EAAQ,CAACC,EAAOC,EAAWC,EAAYC,EAAUC,KACtD,IAAIC,EAAU,GAEdC,EAAM,IAAA,MAAWC,KAAQP,EAAO,CAC/B,MAAMQ,EAAsC,KAAvBD,EAAKE,WAAW,GAErC,IAAA,MAAWC,KAAQF,GAAgBnB,EAAQW,EAAMO,IAASP,EAAMO,GAAQ,CAACP,EAAMO,IAAQ,CACtF,GAAIX,IAAaW,IAASJ,GAAYO,IAASN,GAAW,CACzD,MAAMO,EAAOf,EAASW,EAAMG,EAAMV,GAElC,GAAa,OAATW,EAAe,CAClBN,GAA2B,iBAATM,GAAqBA,EAAOZ,EAAMY,EAAMV,EAAWC,EAAYK,EAAMG,GAAgB,MAARC,EAAe,GAAKA,EAEnH,SAAAL,GAMF,GAFqC,iBAATI,GAAqBA,GAAQA,EAAKlB,WAAaA,EAEzD,CACbK,EAAKe,IAAIX,KACZJ,EAAKgB,OAAOZ,GAEZI,GAAW,KAGZ,MAAMS,EAAWrB,OAAOc,GAElBQ,EAAgBP,EAAeP,EAAYA,EAAUe,OAASrC,EAAqBsB,EAAWM,EAAKU,MAAMvB,IAAUa,EAAKU,MAAMvB,GAEpIW,GAAWN,EAAMW,EAAMK,EAAeP,EAAeN,EAAWgB,OAAOJ,GAAYZ,GAE/EL,EAAKe,IAAIE,KACZjB,EAAKgB,OAAOC,GACZT,GAAW,KAGRR,EAAKe,IAAIG,KACZlB,EAAKgB,OAAOE,GACZV,GAAW,SAEN,CACN,IAAA,IAASc,EAAI,EAAGA,EAAIjB,EAAWc,SAAUG,EACnCtB,EAAKe,IAAIV,EAAWiB,MACxBtB,EAAKuB,IAAIlB,EAAWiB,IAEpBd,GAAWH,EAAWiB,GAAK,KAIzBlB,EAAUe,SAAWnB,EAAKe,IAAIX,KACjCJ,EAAKuB,IAAInB,GAETI,GAAWJ,EAAY,KAGxBI,IAAYG,EAAeD,EAAO,IAAMlC,EAAYkC,GAAQ,KAAOc,OAAOX,GAAQ,MAKrF,OAAOL,GAGR,OAAON,EAAMzB,EAAO,GAAI","sourcesContent":["/** Returns the given value converted to kebab-case. */\nexport const toKebabCase = (/** @type {string} */ value) => (\n\t// ignore kebab-like values\n\tvalue.includes('-')\n\t\t? value\n\t// replace any upper-case letter with a dash and the lower-case variant\n\t: value.replace(/[A-Z]/g, (capital) => '-' + capital.toLowerCase())\n) // prettier-ignore\n\n/** Returns the given value converted to camel-case. */\nexport const toCamelCase = (/** @type {string} */ value) => (!/[A-Z]/.test(value) ? value.replace(/-[^]/g, (capital) => capital[1].toUpperCase()) : value)\n","/** Returns selectors resolved from parent selectors and nested selectors. */\nexport const getResolvedSelectors = (\n\t/** @type {string[]} Parent selectors (e.g. `[\"a\", \"button\"]`). */\n\tparentSelectors,\n\t/** @type {string[]} Nested selectors (e.g. `[\"&:hover\", \"&:focus\"]`). */\n\tnestedSelectors,\n) => (\n\tparentSelectors.reduce(\n\t\t(resolvedSelectors, parentSelector) => {\n\t\t\tresolvedSelectors.push(\n\t\t\t\t...nestedSelectors.map(\n\t\t\t\t\t(selector) => (\n\t\t\t\t\t\tselector.includes('&') ? selector.replace(\n\t\t\t\t\t\t\t/&/g,\n\t\t\t\t\t\t\t/[ +>|~]/.test(parentSelector) && /&.*&/.test(selector)\n\t\t\t\t\t\t\t\t? `:is(${parentSelector})`\n\t\t\t\t\t\t\t: parentSelector\n\t\t\t\t\t\t) : parentSelector + ' ' + selector\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\n\t\t\treturn resolvedSelectors\n\t\t},\n\t\t[]\n\t)\n) // prettier-ignore\n","export const { isArray } = Array\nexport const { from } = Array\n","import { toKebabCase } from './toCase.js'\nimport { getResolvedSelectors } from './getResolvedSelectors.js'\nimport { isArray } from './Array.js'\n\nconst { prototype: { toString } } = Object // prettier-ignore\n\n/** Comma matcher outside rounded brackets. */\nconst comma = /\\s*,\\s*(?![^()]*\\))/\n\n/** Returns a string of CSS from an object of CSS. */\nexport const stringify = (\n\t/** Object representing the current CSS. */\n\tvalue,\n\t/** Replacer function. */\n\treplacer = undefined,\n) => {\n\t/** Set used to manage the opened and closed state of rules. */\n\tconst used = new WeakSet()\n\n\tconst parse = (style, selectors, conditions, prevName, prevData) => {\n\t\tlet cssText = ''\n\n\t\teach: for (const name in style) {\n\t\t\tconst isAtRuleLike = name.charCodeAt(0) === 64\n\n\t\t\tfor (const data of isAtRuleLike && isArray(style[name]) ? style[name] : [style[name]]) {\n\t\t\t\tif (replacer && (name !== prevName || data !== prevData)) {\n\t\t\t\t\tconst next = replacer(name, data, style)\n\n\t\t\t\t\tif (next !== null) {\n\t\t\t\t\t\tcssText += typeof next === 'object' && next ? parse(next, selectors, conditions, name, data) : next == null ? '' : next\n\n\t\t\t\t\t\tcontinue each\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst isObjectLike = typeof data === 'object' && data && data.toString === toString\n\n\t\t\t\tif (isObjectLike) {\n\t\t\t\t\tif (used.has(selectors)) {\n\t\t\t\t\t\tused.delete(selectors)\n\n\t\t\t\t\t\tcssText += '}'\n\t\t\t\t\t}\n\n\t\t\t\t\tconst usedName = Object(name)\n\n\t\t\t\t\tconst nextSelectors = isAtRuleLike ? selectors : selectors.length ? getResolvedSelectors(selectors, name.split(comma)) : name.split(comma)\n\n\t\t\t\t\tcssText += parse(data, nextSelectors, isAtRuleLike ? conditions.concat(usedName) : conditions)\n\n\t\t\t\t\tif (used.has(usedName)) {\n\t\t\t\t\t\tused.delete(usedName)\n\t\t\t\t\t\tcssText += '}'\n\t\t\t\t\t}\n\n\t\t\t\t\tif (used.has(nextSelectors)) {\n\t\t\t\t\t\tused.delete(nextSelectors)\n\t\t\t\t\t\tcssText += '}'\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = 0; i < conditions.length; ++i) {\n\t\t\t\t\t\tif (!used.has(conditions[i])) {\n\t\t\t\t\t\t\tused.add(conditions[i])\n\n\t\t\t\t\t\t\tcssText += conditions[i] + '{'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (selectors.length && !used.has(selectors)) {\n\t\t\t\t\t\tused.add(selectors)\n\n\t\t\t\t\t\tcssText += selectors + '{'\n\t\t\t\t\t}\n\n\t\t\t\t\tcssText += (isAtRuleLike ? name + ' ' : toKebabCase(name) + ':') + String(data) + ';'\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn cssText\n\t}\n\n\treturn parse(value, [], [])\n}\n"]}